"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* global window */
var router_1 = __importDefault(require("next-server/dist/lib/router/router"));
var SingletonRouter = {
    router: null,
    readyCallbacks: [],
    ready: function (cb) {
        if (this.router)
            return cb();
        if (typeof window !== 'undefined') {
            this.readyCallbacks.push(cb);
        }
    }
};
// Create public properties and methods of the router in the SingletonRouter
var urlPropertyFields = ['pathname', 'route', 'query', 'asPath'];
var propertyFields = ['components'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState'];
// Events is a static property on the router, the router doesn't have to be initialized to use it
Object.defineProperty(SingletonRouter, 'events', {
    get: function () {
        return router_1.default.events;
    }
});
propertyFields.concat(urlPropertyFields).forEach(function (field) {
    // Here we need to use Object.defineProperty because, we need to return
    // the property assigned to the actual router
    // The value might get changed as we change routes and this is the
    // proper way to access it
    Object.defineProperty(SingletonRouter, field, {
        get: function () {
            throwIfNoRouter();
            return SingletonRouter.router[field];
        }
    });
});
coreMethodFields.forEach(function (field) {
    SingletonRouter[field] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a;
        throwIfNoRouter();
        return (_a = SingletonRouter.router)[field].apply(_a, args);
    };
});
routerEvents.forEach(function (event) {
    SingletonRouter.ready(function () {
        router_1.default.events.on(event, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var eventField = "on" + event.charAt(0).toUpperCase() + event.substring(1);
            if (SingletonRouter[eventField]) {
                try {
                    SingletonRouter[eventField].apply(SingletonRouter, args);
                }
                catch (err) {
                    console.error("Error when running the Router event: " + eventField);
                    console.error(err.message + "\n" + err.stack);
                }
            }
        });
    });
});
function throwIfNoRouter() {
    if (!SingletonRouter.router) {
        var message = 'No router instance found.\n' +
            'You should only use "next/router" inside the client side of your app.\n';
        throw new Error(message);
    }
}
// Export the SingletonRouter and this is the public API.
exports.default = SingletonRouter;
// Reexport the withRoute HOC
var with_router_1 = require("./with-router");
exports.withRouter = with_router_1.default;
// INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.
exports.createRouter = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    SingletonRouter.router = new (router_1.default.bind.apply(router_1.default, [void 0].concat(args)))();
    SingletonRouter.readyCallbacks.forEach(function (cb) { return cb(); });
    SingletonRouter.readyCallbacks = [];
    return SingletonRouter.router;
};
// Export the actual Router class, which is usually used inside the server
exports.Router = router_1.default;
// This function is used to create the `withRouter` router instance
function makePublicRouterInstance(router) {
    var instance = {};
    for (var _i = 0, urlPropertyFields_1 = urlPropertyFields; _i < urlPropertyFields_1.length; _i++) {
        var property = urlPropertyFields_1[_i];
        if (typeof router[property] === 'object') {
            instance[property] = __assign({}, router[property]); // makes sure query is not stateful
            continue;
        }
        instance[property] = router[property];
    }
    // Events is a static property on the router, the router doesn't have to be initialized to use it
    instance.events = router_1.default.events;
    propertyFields.forEach(function (field) {
        // Here we need to use Object.defineProperty because, we need to return
        // the property assigned to the actual router
        // The value might get changed as we change routes and this is the
        // proper way to access it
        Object.defineProperty(instance, field, {
            get: function () {
                return router[field];
            }
        });
    });
    coreMethodFields.forEach(function (field) {
        instance[field] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return router[field].apply(router, args);
        };
    });
    return instance;
}
exports.makePublicRouterInstance = makePublicRouterInstance;
