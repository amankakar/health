"use strict";
/* global __NEXT_DATA__ */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var url_1 = require("url");
var react_1 = __importStar(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var router_1 = __importStar(require("next/router"));
var utils_1 = require("next-server/dist/lib/utils");
function isLocal(href) {
    var url = url_1.parse(href, false, true);
    var origin = url_1.parse(utils_1.getLocationOrigin(), false, true);
    return !url.host ||
        (url.protocol === origin.protocol && url.host === origin.host);
}
function memoizedFormatUrl(formatUrl) {
    var lastHref = null;
    var lastAs = null;
    var lastResult = null;
    return function (href, as) {
        if (href === lastHref && as === lastAs) {
            return lastResult;
        }
        var result = formatUrl(href, as);
        lastHref = href;
        lastAs = as;
        lastResult = result;
        return result;
    };
}
var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // The function is memoized so that no extra lifecycles are needed
        // as per https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html
        _this.formatUrls = memoizedFormatUrl(function (href, asHref) {
            return {
                href: href && typeof href === 'object'
                    ? url_1.format(href)
                    : href,
                as: asHref && typeof asHref === 'object'
                    ? url_1.format(asHref)
                    : asHref
            };
        });
        _this.linkClicked = function (e) {
            var _a = e.currentTarget, nodeName = _a.nodeName, target = _a.target;
            if (nodeName === 'A' &&
                ((target && target !== '_self') || e.metaKey || e.ctrlKey || e.shiftKey || (e.nativeEvent && e.nativeEvent.which === 2))) {
                // ignore click for new tab / new window behavior
                return;
            }
            var _b = _this.formatUrls(_this.props.href, _this.props.as), href = _b.href, as = _b.as;
            if (!isLocal(href)) {
                // ignore click if it's outside our scope
                return;
            }
            var pathname = window.location.pathname;
            href = url_1.resolve(pathname, href);
            as = as ? url_1.resolve(pathname, as) : href;
            e.preventDefault();
            //  avoid scroll for urls with anchor refs
            var scroll = _this.props.scroll;
            if (scroll == null) {
                scroll = as.indexOf('#') < 0;
            }
            // replace state instead of push if prop is present
            router_1.default[_this.props.replace ? 'replace' : 'push'](href, as, { shallow: _this.props.shallow })
                .then(function (success) {
                if (!success)
                    return;
                if (scroll) {
                    window.scrollTo(0, 0);
                    document.body.focus();
                }
            })
                .catch(function (err) {
                if (_this.props.onError)
                    _this.props.onError(err);
            });
        };
        return _this;
    }
    Link.prototype.componentDidMount = function () {
        this.prefetch();
    };
    Link.prototype.componentDidUpdate = function (prevProps) {
        if (JSON.stringify(this.props.href) !== JSON.stringify(prevProps.href)) {
            this.prefetch();
        }
    };
    Link.prototype.prefetch = function () {
        if (!this.props.prefetch)
            return;
        if (typeof window === 'undefined')
            return;
        // Prefetch the JSON page if asked (only in the client)
        var pathname = window.location.pathname;
        var parsedHref = this.formatUrls(this.props.href, this.props.as).href;
        var href = url_1.resolve(pathname, parsedHref);
        router_1.default.prefetch(href);
    };
    Link.prototype.render = function () {
        var _this = this;
        var children = this.props.children;
        var _a = this.formatUrls(this.props.href, this.props.as), href = _a.href, as = _a.as;
        // Deprecated. Warning shown by propType check. If the childen provided is a string (<Link>example</Link>) we wrap it in an <a> tag
        if (typeof children === 'string') {
            children = react_1.default.createElement("a", null, children);
        }
        // This will return the first child, if multiple are provided it will throw an error
        var child = react_1.Children.only(children);
        var props = {
            onClick: function (e) {
                if (child.props && typeof child.props.onClick === 'function') {
                    child.props.onClick(e);
                }
                if (!e.defaultPrevented) {
                    _this.linkClicked(e);
                }
            }
        };
        // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
        // defined, we specify the current 'href', so that repetition is not needed by the user
        if (this.props.passHref || (child.type === 'a' && !('href' in child.props))) {
            props.href = as || href;
        }
        // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly.
        if (props.href &&
            typeof __NEXT_DATA__ !== 'undefined' &&
            __NEXT_DATA__.nextExport) {
            props.href = router_1.Router._rewriteUrlForNextExport(props.href);
        }
        return react_1.default.cloneElement(child, props);
    };
    return Link;
}(react_1.Component));
if (process.env.NODE_ENV === 'development') {
    var warn_1 = utils_1.execOnce(console.error);
    // This module gets removed by webpack.IgnorePlugin
    var exact = require('prop-types-exact');
    Link.propTypes = exact({
        href: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.object]).isRequired,
        as: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.object]),
        prefetch: prop_types_1.default.bool,
        replace: prop_types_1.default.bool,
        shallow: prop_types_1.default.bool,
        passHref: prop_types_1.default.bool,
        scroll: prop_types_1.default.bool,
        children: prop_types_1.default.oneOfType([
            prop_types_1.default.element,
            function (props, propName) {
                var value = props[propName];
                if (typeof value === 'string') {
                    warn_1("Warning: You're using a string directly inside <Link>. This usage has been deprecated. Please add an <a> tag as child of <Link>");
                }
                return null;
            }
        ]).isRequired
    });
}
exports.default = Link;
